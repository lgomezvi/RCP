# ChromaDB Endpoint Implementation Instructions

This document outlines the steps to implement two endpoints for interacting with a cloud-deployed ChromaDB instance.

## Prerequisites

1.  **ChromaDB Cloud Instance:** Ensure your ChromaDB instance is deployed and accessible in the cloud. You will need its host and port (or API key if applicable).
2.  **Python Environment:** A Python environment with `flask` and `chromadb` installed.
    `pip install flask chromadb`
3.  **Embedding Model:** Decide on the embedding model you will use. If your ChromaDB instance is configured with a default embedding function, you might not need to explicitly embed the query on the client side. If not, you'll need a library like `sentence-transformers` or `openai` for embeddings.

## Endpoint 1: Query Vector DB

This endpoint will take a user query string, embed it (if necessary), and then query the ChromaDB instance to find similar documents.

### `POST /query`

**Request Body:**

```json
{
    "query_string": "What are the main features of the new product?"
}
```

**Steps:**

1.  **Receive Query:** Accept a JSON payload containing `query_string` from the incoming POST request.
2.  **Initialize ChromaDB Client:**
    *   Connect to your cloud ChromaDB instance.
    *   Example: `client = chromadb.HttpClient(host="your_chromadb_host", port="your_chromadb_port")`
    *   Get the target collection: `collection = client.get_or_create_collection(name="your_collection_name")`
3.  **Embed Query (if needed):**
    *   If your ChromaDB collection does *not* have an embedding function configured, you will need to embed the `query_string` using your chosen embedding model.
    *   Example (using a hypothetical embedding function): `query_embedding = embed_text(query_string)`
4.  **Query ChromaDB:**
    *   Use the `collection.query()` method.
    *   If you embedded the query on the client side: `results = collection.query(query_embeddings=[query_embedding], n_results=5)`
    *   If ChromaDB handles embeddings: `results = collection.query(query_texts=[query_string], n_results=5)`
    *   Adjust `n_results` as needed.
5.  **Process Results:** Extract relevant information (e.g., `documents`, `metadatas`, `distances`) from the `results` object.
6.  **Return Response:** Send back the query results as a JSON response.

## Endpoint 2: Add New Documents

This endpoint will allow users to add new documents (text and associated metadata) to the ChromaDB instance.

### `POST /add_documents`

**Request Body:**

```json
{
    "documents": [
        {
            "text": "This is the first document about product features.",
            "metadata": {"source": "manual_entry", "author": "John Doe"}
        },
        {
            "text": "The second document discusses pricing models.",
            "metadata": {"source": "website_scrape", "date": "2023-10-26"}
        }
    ]
}
```

**Steps:**

1.  **Receive Documents:** Accept a JSON payload containing a list of document objects, each with `text` and `metadata`.
2.  **Initialize ChromaDB Client:** (Same as Endpoint 1)
    *   `client = chromadb.HttpClient(host="your_chromadb_host", port="your_chromadb_port")`
    *   `collection = client.get_or_create_collection(name="your_collection_name")`
3.  **Prepare Data for ChromaDB:**
    *   Iterate through the received documents.
    *   Collect `texts`, `metadatas`, and generate unique `ids` for each document.
    *   Example:
        ```python
        texts = [doc["text"] for doc in documents_payload]
        metadatas = [doc["metadata"] for doc in documents_payload]
        ids = [f"doc_{i}" for i in range(len(documents_payload))] # Or use a more robust ID generation
        ```
4.  **Add Documents to ChromaDB:**
    *   Use the `collection.add()` method.
    *   `collection.add(documents=texts, metadatas=metadatas, ids=ids)`
5.  **Return Response:** Confirm successful addition of documents.

## Example Flask Structure (main.py)

```python
from flask import Flask, request, jsonify
import chromadb
# from sentence_transformers import SentenceTransformer # Uncomment if you need client-side embeddings

app = Flask(__name__)

# Initialize ChromaDB client globally or within a function if preferred
# client = chromadb.HttpClient(host="your_chromadb_host", port="your_chromadb_port")
# collection = client.get_or_create_collection(name="your_collection_name")

# If using client-side embeddings
# embedding_model = SentenceTransformer('all-MiniLM-L6-v2')

@app.route('/query', methods=['POST'])
def query_db():
    data = request.get_json()
    query_string = data.get('query_string')

    if not query_string:
        return jsonify({"error": "query_string is required"}), 400

    # Re-initialize client/collection if not global, or use the global ones
    client = chromadb.HttpClient(host="your_chromadb_host", port="your_chromadb_port")
    collection = client.get_or_create_collection(name="your_collection_name")

    # Example for client-side embedding (uncomment if needed)
    # query_embedding = embedding_model.encode([query_string]).tolist()[0]
    # results = collection.query(query_embeddings=[query_embedding], n_results=5)

    # Example for ChromaDB-side embedding (if collection has an embedding function)
    results = collection.query(query_texts=[query_string], n_results=5)

    return jsonify(results)

@app.route('/add_documents', methods=['POST'])
def add_docs():
    data = request.get_json()
    documents_payload = data.get('documents')

    if not documents_payload or not isinstance(documents_payload, list):
        return jsonify({"error": "documents (list of objects with 'text' and 'metadata') is required"}), 400

    texts = [doc["text"] for doc in documents_payload]
    metadatas = [doc["metadata"] for doc in documents_payload]
    ids = [f"doc_{i}" for i in range(len(documents_payload))] # Simple ID generation, consider UUIDs for production

    # Re-initialize client/collection if not global, or use the global ones
    client = chromadb.HttpClient(host="your_chromadb_host", port="your_chromadb_port")
    collection = client.get_or_create_collection(name="your_collection_name")

    try:
        collection.add(documents=texts, metadatas=metadatas, ids=ids)
        return jsonify({"message": f"Successfully added {len(documents_payload)} documents."}), 201
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)
```
